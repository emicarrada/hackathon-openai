{
  "gpt3": {
    "modelo": "gpt-3.5-turbo",
    "tiempo": 7.018609046936035,
    "respuesta": "1. Recursiva simple\n\n```python\ndef fibonacci_recursive(n: int) -> int:\n    \"\"\"\n    Calcula el n-\u00e9simo n\u00famero de la secuencia de Fibonacci de forma recursiva.\n\n    Args:\n    n: El \u00edndice del n\u00famero de la secuencia de Fibonacci a calcular.\n\n    Returns:\n    El n-\u00e9simo n\u00famero de la secuencia de Fibonacci.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n```\n\nComplejidad temporal: O(2^n) - Exponencial\nComplejidad espacial: O(n) - Debido a la pila de llamadas recursivas\n\nEjemplo de uso:\n```python\nprint(fibonacci_recursive(5))  # Output: 5\n```\n\n2. Con memoizaci\u00f3n\n\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci_memoization(n: int) -> int:\n    \"\"\"\n    Calcula el n-\u00e9simo n\u00famero de la secuencia de Fibonacci con memoizaci\u00f3n.\n\n    Args:\n    n: El \u00edndice del n\u00famero de la secuencia de Fibonacci a calcular.\n\n    Returns:\n    El n-\u00e9simo n\u00famero de la secuencia de Fibonacci.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fibonacci_memoization(n-1) + fibonacci_memoization(n-2)\n```\n\nComplejidad temporal: O(n) - Lineal\nComplejidad espacial: O(n) - Debido al uso de memoizaci\u00f3n\n\nEjemplo de uso:\n```python\nprint(fibonacci_memoization(5))  # Output: 5\n```\n\n3. Iterativa\n\n```python\ndef fibonacci_iterative(n: int) -> int:\n    \"\"\"\n    Calcula el n-\u00e9simo n\u00famero de la secuencia de Fibonacci de forma iterativa.\n\n    Args:\n    n: El \u00edndice del n\u00famero de la secuencia de Fibonacci a calcular.\n\n    Returns:\n    El n-\u00e9simo n\u00famero de la secuencia de Fibonacci.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for _ in range(2, n+1):\n        a, b = b, a + b\n    \n    return b\n```\n\nComplejidad temporal: O(n) - Lineal\nComplejidad espacial: O(1) - Constante\n\nEjemplo de uso:\n```python\nprint(fibonacci_iterative(5))  # Output: 5\n```\n\nComparaci\u00f3n y explicaci\u00f3n:\n- La versi\u00f3n recursiva simple es la m\u00e1s sencilla de implementar, pero tiene una complejidad exponencial, lo que la hace ineficiente para n\u00fameros grandes.\n- La versi\u00f3n con memoizaci\u00f3n mejora la eficiencia de la versi\u00f3n recursiva al almacenar los resultados de los c\u00e1lculos previos, evitando as\u00ed recalcularlos. Esto reduce la complejidad temporal a lineal.\n- La versi\u00f3n iterativa es la m\u00e1s eficiente, ya que no utiliza recursi\u00f3n ni memoizaci\u00f3n, y tiene una complejidad temporal y espacial lineal. Es la mejor opci\u00f3n para calcular n\u00fameros de la secuencia de Fibonacci de forma eficiente.",
    "exitoso": true
  },
  "gpt4o": {
    "modelo": "gpt-4o",
    "tiempo": 13.087007999420166,
    "respuesta": "Vamos a implementar las tres versiones de la funci\u00f3n Fibonacci en Python, con tipos, documentaci\u00f3n, an\u00e1lisis de complejidad, y ejemplos de uso.\n\n### 1. Recursiva Simple\n\n```python\ndef fibonacci_recursive(n: int) -> int:\n    \"\"\"\n    Calcula el n-\u00e9simo n\u00famero de Fibonacci de manera recursiva.\n\n    :param n: El \u00edndice del n\u00famero de Fibonacci a calcular.\n    :return: El n-\u00e9simo n\u00famero de Fibonacci.\n\n    Complejidad:\n    - Temporal: O(2^n)\n    - Espacial: O(n) (debido a la pila de llamadas recursivas)\n\n    Ejemplo de uso:\n    >>> fibonacci_recursive(5)\n    5\n    >>> fibonacci_recursive(10)\n    55\n    \"\"\"\n    if n <= 1:\n        return n\n    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n```\n\n**An\u00e1lisis:**\n- La versi\u00f3n recursiva simple es la m\u00e1s directa, pero tambi\u00e9n la menos eficiente.\n- Cada llamada a `fibonacci_recursive` hace dos llamadas adicionales, lo que lleva a una explosi\u00f3n combinatoria de llamadas.\n- La complejidad temporal es exponencial, O(2^n), debido al gran n\u00famero de c\u00e1lculos repetidos.\n- La complejidad espacial es O(n) debido a la profundidad de la pila de llamadas.\n\n### 2. Con Memoizaci\u00f3n\n\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci_memoization(n: int) -> int:\n    \"\"\"\n    Calcula el n-\u00e9simo n\u00famero de Fibonacci usando memoizaci\u00f3n para optimizar.\n\n    :param n: El \u00edndice del n\u00famero de Fibonacci a calcular.\n    :return: El n-\u00e9simo n\u00famero de Fibonacci.\n\n    Complejidad:\n    - Temporal: O(n)\n    - Espacial: O(n) (almacenamiento de resultados)\n\n    Ejemplo de uso:\n    >>> fibonacci_memoization(5)\n    5\n    >>> fibonacci_memoization(10)\n    55\n    \"\"\"\n    if n <= 1:\n        return n\n    return fibonacci_memoization(n - 1) + fibonacci_memoization(n - 2)\n```\n\n**An\u00e1lisis:**\n- La memoizaci\u00f3n mejora significativamente el rendimiento al almacenar resultados ya calculados.\n- La complejidad temporal se reduce a O(n) porque cada resultado se calcula solo una vez.\n- La complejidad espacial sigue siendo O(n) debido al almacenamiento de resultados en cach\u00e9.\n- Esta versi\u00f3n es mucho m\u00e1s eficiente que la recursiva simple, especialmente para valores grandes de `n`.\n\n### 3. Iterativa\n\n```python\ndef fibonacci_iterative(n: int) -> int:\n    \"\"\"\n    Calcula el n-\u00e9simo n\u00famero de Fibonacci de manera iterativa.\n\n    :param n: El \u00edndice del n\u00famero de Fibonacci a calcular.\n    :return: El n-\u00e9simo n\u00famero de Fibonacci.\n\n    Complejidad:\n    - Temporal: O(n)\n    - Espacial: O(1)\n\n    Ejemplo de uso:\n    >>> fibonacci_iterative(5)\n    5\n    >>> fibonacci_iterative(10)\n    55\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n\n**An\u00e1lisis:**\n- La versi\u00f3n iterativa es la m\u00e1s eficiente en t\u00e9rminos de uso de memoria.\n- La complejidad temporal es O(n), similar a la versi\u00f3n con memoizaci\u00f3n.\n- La complejidad espacial es O(1) porque solo se utilizan unas pocas variables para el c\u00e1lculo.\n- Esta versi\u00f3n es ideal cuando se busca optimizar tanto el tiempo como el espacio, especialmente \u00fatil en sistemas con recursos limitados.\n\n### Comparaci\u00f3n y Mejora\n\n1. **Recursiva Simple vs. Memoizaci\u00f3n:**\n   - La memoizaci\u00f3n reduce dr\u00e1sticamente el n\u00famero de c\u00e1lculos redundantes, mejorando la eficiencia de O(2^n) a O(n).\n\n2. **Memoizaci\u00f3n vs. Iterativa:**\n   - La versi\u00f3n iterativa mantiene la misma eficiencia temporal pero mejora la eficiencia espacial de O(n) a O(1).\n\nEn resumen, cada versi\u00f3n mejora a la anterior en t\u00e9rminos de eficiencia, con la versi\u00f3n iterativa siendo la m\u00e1s optimizada para c\u00e1lculos de Fibonacci.",
    "exitoso": true
  },
  "tarea": "Implementa tres versiones de la funci\u00f3n Fibonacci en Python:\n1. Recursiva simple\n2. Con memoizaci\u00f3n\n3. Iterativa\n\nPara cada versi\u00f3n:\n- Incluye tipos (type hints)\n- Documentaci\u00f3n completa\n- An\u00e1lisis de complejidad temporal y espacial\n- Ejemplos de uso\n\nCompara y explica por qu\u00e9 cada versi\u00f3n mejora la anterior."
}